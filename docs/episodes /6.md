# 6. Batch correction and data set integration 

!!! quote ""

    Often, single-cell experiments are done by processing samples in multiple batches. This may be related to logistical constraints such as the inability to run all experimental conditions in parallel, or more extreme cases where samples are processed in different laboratories, by different people and even sequenced with different technologies (e.g. samples from human patients collected in different hospitals). These differences across sample batches very often result in global gene expression differences across those batches. Since batch-to-batch transcriptomic differences are likely unrelated to biological differences, we would ideally want “remove” them before drawing inferences about our cell populations.

    Biases due to batch effects are not new to single-cell RNA-seq. Indeed, several methods have been previously developed for standard bulk RNA-seq approaches. Some of those approaches rely on linear models that “regress out” the batch effect, assuming that the cell composition is similar across batches. However, in single-cell RNA-seq we may very often expect changes in cell compositions across batches (e.g. in our course data we have data from cancer samples such as ETV6-RUNX as well as a reference panel of healthy blood cells, PBMMCs). Therefore, methods are necessary that can deal with with heterogeneity across batches.

    In recent years, several methods have been developed to deal with this challenge ([too many to list here!](https://www.scrna-tools.org/tools?sort=name&cats=Integration)). Some of the most popular ones include the Mutual Nearest Neighbours (MNN) algorithm, a Principal Components Analysis-based clustering method implemented in the package HARMONY and a method that combines Canonical Correlation Analysis (CCC) and MNN implemented in the package Seurat 3. These methods have been shown to perform well in several benchmark studies (e.g. Luecken et al 2022 and Tran et al 2020), although one important message from these studies is that no **single method is universally the best in all situations**. For example, some methods may be better at preserving small populations of cells as separate groups in the integrated data at the cost of poorer overall integration, while others may be better at removing batch effects at the cost of also removing some biological signal.

    In this section we will apply the **Mutual Nearest Neighbours (MNN)** algorithm, which is readily available to use with the `SingleCellExperiment`` object we’ve been working with so far. However, other methods can be applied to the data in a similar manner (each package may use a slightly different syntax, but they mostly start with either a matrix of counts or a PCA projection). Therefore, what we will explore in this section - visualisation of the integrated data, looking at mixture of cell populations, etc. - can be done with those other methods as well.

## Example data set - PBMMC_1 technical replicates

To demonstrate the integration process, we will two samples from the Caron dataset that will illustrate the purposes of dataset integration with batch correction. One is the PBMMC_1 sample that we have already seen, the other is a technical replicate derived from the same sample material (we will use our previous SCE object in a later exercise).

Whilst the two samples come from distinct 10X runs they are derived from the same starting material and therefore, if there was no batch effect, they should be identical. These samples have been processed as discussed up until this point in the course:

- Raw counts were imported from the cellranger output folder (using `DropletUtils::read10xCounts()`).
- Basic quality filtering was performed in each batch to remove cells that were outliers for total counts, number of detected genes and high percentage of mitochondrial counts (using `scuttle::quickPerCellQC()`).
- Reads were log-normalised using the deconvolution method (using `scuttle::computePooledFactors()`).

We already have the necessary objects prepared, and load them for this session:

!!! r-project "code"

    ```r
    library(scater)
    library(scran)
    library(batchelor)
    library(bluster)
    library(pheatmap)
    library(magrittr)
    ```
    ```r
    sce_rep1 <- readRDS("R_objects/PBMMC_1a_dimRed.rds")
    sce_rep2 <- readRDS("R_objects/PBMMC_1b_dimRed.rds")
    ```

    - First we should add information about which technical replicate each sample is. This is added as a new column in the colData DataFrame of the object.

    ```r
    colData(sce_rep1)$batch <- "1"
    colData(sce_rep2)$batch <- "2"
    ```

## Data Preparation

!!! circle-info ""

Before the data integration step, we need to prepare our data (we will later see how we can run all these steps with a single function, but it is good to see all the steps individually).

1. First we need to fit a mean-variance mode to each data set separately (using `scran::modelGeneVar()``). This will be used later to identify highly-variable genes (HVGs) in each batch.
2. Subset our objects to only include the set of genes that are common in both samples (in case different genes were filtered out).
3. Rescale the batches to account for different sequencing depths. We had previously log-normalised the counts in each batch. However, this did not take into account differences in total sequencing depth across different batches. This step therefore helps to bring the different batches to a “similar scale”, which helps with the data integration step.
4.Select variable genes (feature selection), by averaging the variance previously estimated in each batch separately. This will gives us genes that are highly variable across both batches.

!!! r-project-2 "Fit mean-variance mode to each data set"

    ```r
    gene_var_rep1 <- modelGeneVar(sce_rep1)
    gene_var_rep2 <- modelGeneVar(sce_rep2)
    ```
!!! r-project-2 "Identify common genes and subset both the sce objects and the mean-variance model objects"

    The two samples have been QC’d and filtered independently. Removing undetected genes from each set independently has results in slightly different genes being retained in each dataset:
    ```r
    nrow(sce_rep1)
    ```
    ```r
    nrow(sce_rep2)
    ```
    ```r
    sum(rowData(sce_rep1)$ID%in%rowData(sce_rep2)$ID)
    ```
    ```r
    common_genes <- intersect(rownames(sce_rep1), rownames(sce_rep2))
    ```

    - Subset the SCE object

    ```r
    sce_rep1 <- sce_rep1[common_genes, ]
    sce_rep2 <- sce_rep2[common_genes, ]
    ```

    - Subset the mean-variance results

    ```r
    gene_var_rep1 <- gene_var_rep1[common_genes, ]
    gene_var_rep2 <- gene_var_rep2[common_genes, ]
    ```

!!! r-project-2 "Rescale and combine data"

    ```r
    rescaled_sces <- multiBatchNorm(sce_rep1, sce_rep2)

    sce <- cbind(rescaled_sces[[1]], 
                 rescaled_sces[[2]])
    ```

!!! r-project-2 "Combine gene variance models and identify HVGs"

    ```r
    gene_var_combined <- combineVar(gene_var_rep1, gene_var_rep2)

    hvgs <- gene_var_combined$bio > 0
    sum(hvgs)
    ```
## Visualising Uncorrected Data

Before running the data integration procedure, it is always good to check how much of a problem the batch effect might be. This is typically done by visualising the combined data in a reduced dimensionality projection such as t-SNE or UMAP.

Another strategy to check for batch effects, involves clustering the cells (we will cover cell clustering in detail later) and checking whether both batches are represented in each cluster. If clusters contain cells from only one of the clusters, this may indicate a batch effect is present.

!!! r-project "code"

    ```r
    sce <- runPCA(sce, subset_row = hvgs)

    sce$cluster_uncorrected <- clusterCells(sce, use.dimred = "PCA")

    sce <- runTSNE(sce, dimred = "PCA", name = "TSNE_uncorrected")

    plotReducedDim(sce, dimred = "TSNE_uncorrected",
                   colour_by = "batch",
                   text_by = "cluster_uncorrected")
    ```
    ![image](../r_images/41-batchcorrect-visualisinguncorrected.png)

    - We can also assess cluster occupancy data as a table.
    ```r
    table(Cluster = sce$cluster_uncorrected, Batch = sce$batch)
    ```
!!! quote ""
    As we can see from the t-SNE, cells seem to somewhat separate according to batch (although distinct groups of cells are still visible at a more global scale).
    
    We can also see that some of the clusters identified in the data contain an unbalanced number of cells from each batch.
    
    However, from the t-SNE, there is some suggestion that these could be the same cell type. Another example is cluster 7, which contains cells from both batches, but on the t-SNE there is still some within-batch separation of these cells (if we formed sub-clusters they would likely separate by batch).
    
    It is worth noting that, although this suggests a batch effect (and in the case of technical replicates this is a good assumption), there might be cases where there are genuine differences in cell populations across batches (e.g. if the different batches represent samples from different tissues).
    
    Data integration algorithms designed for single-cell RNA-seq do allow for unique cell types existing across batches, however, it’s always good to check the results of the integration using independent information (e.g. prior information about genes that are specific to particular cell types).


## Correct the data - Mutual Nearest Neighbour (MNN)

The *Mutual Nearest Neighbours* (MNN) algorithm works by determining if pairs of cells from two different batches are within the top K closest neighbours of each other.

!!! image "Schematic of the MNN algorithm  - Reference: [Haghverdi et al 2018](https://www.nature.com/articles/nbt.4091)"

    Here are the assumptions of this approach (taken from Haghverdi et al 2018):

    1. There is at least one cell population that is present in both batches,
    2. The batch effect is almost orthogonal [i.e. uncorrelated] to the biological subspace
    3. The batch-effect variation is much smaller than the biological-effect variation between different cell types

    <center>![image](../r_images/batchcorrection-MNN.png){width="600"}</center>

!!! r-project-2 "We will use the `fastMNN()`` function. We will need to provide the following:"

    - The SCE object(s) with the log-normalised counts to correct.
    - `batch`` - A variable specifying the batch labels for each cell (usually we include that information as a column in the colData slot of the object).
    - `d`` - The number of dimensions to use from a PCA projection of the data (the method uses PCA values for computational efficiency - and it has also been shown to often perform better than using the full matrix of logcounts).
    - `k` - The number of cells to consider when calculating the mutual nearest neighbours between each pair of cells.
    - `subset.row`` - The genes to use for the PCA step of the algorithm. We use the highly-variable genes determined earlier from the pooled mean-variance model.

    ```r
    mnn_corrected <- fastMNN(sce, 
                             batch = sce$batch,
                             d = 50,
                             k = 20, 
                             subset.row = hvgs)
    mnn_corrected
    ```

The result of the function is a new `SingleCellExperiment` object with a “corrected” matrix in the reducedDims slot, containing corrected low-dimensional coordinates for each cell. This “corrected” matrix can be used in downstream analyses such as clustering.

The new object also contains a “reconstructed” matrix in the assays slot. This can be viewed as per-gene corrected log-expression values, but should not be used for any quantitative analyses as the magnitude and even the direction of differences in expression between cells may not have been preserved.

!!! r-project-2 "We can add the “corrected” matrix to our original SCE object, so that we keep all the data together in the same object."

    ```r
    reducedDim(sce, "corrected") <- reducedDim(mnn_corrected, "corrected")
    ```

??? clipboard-question "How many neighbours (k) should we consider?"

    The answer to this question - as is often the case in bioinformatics! - is that this will depend on the dataset. One heuristic to use is to think about what is the minimum number a given cell type that you expect to be shared between the batches. For example, the value `k = 20` is approximately equivalent to assuming that we expect there to be a group of a least 20 cells of one type in one batch that have an equivalent group of 20 or more cells of the same type in the other batch.

    Sometimes, based on the analysis of known cell-specific marker genes, we may notice that some batch-specific clusters should have been merged, but are not. In those cases, increasing the number of k neighbours will result in a stronger integration (we are effectively increasing the chance that a given pair of cells are mutual neighbours of each other).